// Code generated by MockGen. DO NOT EDIT.
// Source: deploy.go
//
// Generated by this command:
//
//	mockgen -source=deploy.go -package=deploy -destination=mock_deploy.go
//
// Package deploy is a generated GoMock package.
package deploy

import (
	reflect "reflect"
	time "time"

	glog "github.com/golang/glog"
	namespace "github.com/openshift-kni/eco-goinfra/pkg/namespace"
	gomock "go.uber.org/mock/gomock"
)

// MockDeploy is a mock of Deploy interface.
type MockDeploy struct {
	ctrl     *gomock.Controller
	recorder *MockDeployMockRecorder
}

// MockDeployMockRecorder is the mock recorder for MockDeploy.
type MockDeployMockRecorder struct {
	mock *MockDeploy
}

// NewMockDeploy creates a new mock instance.
func NewMockDeploy(ctrl *gomock.Controller) *MockDeploy {
	mock := &MockDeploy{ctrl: ctrl}
	mock.recorder = &MockDeployMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDeploy) EXPECT() *MockDeployMockRecorder {
	return m.recorder
}

// CreateAndLabelNamespaceIfNeeded mocks base method.
func (m *MockDeploy) CreateAndLabelNamespaceIfNeeded(logLevel glog.Level, targetNs string, labels map[string]string) (*namespace.Builder, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateAndLabelNamespaceIfNeeded", logLevel, targetNs, labels)
	ret0, _ := ret[0].(*namespace.Builder)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateAndLabelNamespaceIfNeeded indicates an expected call of CreateAndLabelNamespaceIfNeeded.
func (mr *MockDeployMockRecorder) CreateAndLabelNamespaceIfNeeded(logLevel, targetNs, labels any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateAndLabelNamespaceIfNeeded", reflect.TypeOf((*MockDeploy)(nil).CreateAndLabelNamespaceIfNeeded), logLevel, targetNs, labels)
}

// DeployBundle mocks base method.
func (m *MockDeploy) DeployBundle(logLevel glog.Level, bundleConfig *BundleConfig, ns string, timeout time.Duration) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeployBundle", logLevel, bundleConfig, ns, timeout)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeployBundle indicates an expected call of DeployBundle.
func (mr *MockDeployMockRecorder) DeployBundle(logLevel, bundleConfig, ns, timeout any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeployBundle", reflect.TypeOf((*MockDeploy)(nil).DeployBundle), logLevel, bundleConfig, ns, timeout)
}

// GetBundleConfig mocks base method.
func (m *MockDeploy) GetBundleConfig(logLevel glog.Level) (*BundleConfig, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBundleConfig", logLevel)
	ret0, _ := ret[0].(*BundleConfig)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBundleConfig indicates an expected call of GetBundleConfig.
func (mr *MockDeployMockRecorder) GetBundleConfig(logLevel any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBundleConfig", reflect.TypeOf((*MockDeploy)(nil).GetBundleConfig), logLevel)
}

// WaitForReadyStatus mocks base method.
func (m *MockDeploy) WaitForReadyStatus(logLevel glog.Level, name, ns string, timeout time.Duration) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WaitForReadyStatus", logLevel, name, ns, timeout)
	ret0, _ := ret[0].(error)
	return ret0
}

// WaitForReadyStatus indicates an expected call of WaitForReadyStatus.
func (mr *MockDeployMockRecorder) WaitForReadyStatus(logLevel, name, ns, timeout any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WaitForReadyStatus", reflect.TypeOf((*MockDeploy)(nil).WaitForReadyStatus), logLevel, name, ns, timeout)
}
